//
//  NoteTableWorker.swift
//  NotesApp
//
//  Created by Сашок on 14.05.2022.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import CoreData

class NoteTableWorker {
    private(set) var persistentContainer: NSPersistentContainer
    private weak var fetchedResultsControllerDelegate: NSFetchedResultsControllerDelegate?
    
    private(set) lazy var fetchedResultsController: NSFetchedResultsController<NoteMO> = {
        let fetchRequest = NoteMO.fetchRequest()
        fetchRequest.sortDescriptors = [NSSortDescriptor(key: "pinned", ascending: false),
                                        NSSortDescriptor(key: "date", ascending: false)]
        
        let controller = NSFetchedResultsController(fetchRequest: fetchRequest,
                                                    managedObjectContext: persistentContainer.viewContext,
                                                    sectionNameKeyPath: nil,
                                                    cacheName: nil)
        controller.delegate = fetchedResultsControllerDelegate
        
        return controller
    }()
    
    init(persistentContainer: NSPersistentContainer,
         fetchedResultsControllerDelegate: NSFetchedResultsControllerDelegate?) {
        self.persistentContainer = persistentContainer
        self.fetchedResultsControllerDelegate = fetchedResultsControllerDelegate
        
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(managedObjectContextDidSave),
                                               name: .NSManagedObjectContextDidSave, object: nil)
    }
    
    func fetchNotes() {
        do {
            try fetchedResultsController.performFetch()
        } catch {
            fatalError("\(#function): Failed to performFetch: \(error)")
        }
    }
    
    func addNote(completion: @escaping (IndexPath?) -> Void) {
        CoreDataService.shared.addNote(in: persistentContainer.viewContext) { newNote in
            YandexDiskSynchronizatinManager.shared.uploadNote(newNote)
            
            let indexPath = self.fetchedResultsController.indexPath(forObject: newNote)
            completion(indexPath)
        }
    }

    func deleteNote(at indexPath: IndexPath) {
        let note = fetchedResultsController.object(at: indexPath)
        
        YandexDiskSynchronizatinManager.shared.deleteNote(note)
        CoreDataService.shared.delete(note: note)
    }
    
    func pinNote(at indexPath: IndexPath) {
        let note = fetchedResultsController.object(at: indexPath)
        note.pinned.toggle()
        
        YandexDiskSynchronizatinManager.shared.uploadNote(note)
        CoreDataService.shared.save(note: note)
    }
    
    func filterNotes(searchText: String) {
        var searchPredicate: NSPredicate?
        if !searchText.isEmpty {
            searchPredicate =
                NSPredicate(format: "(title contains[cd] %@) || (content contains[cd] %@)", searchText, searchText)
        }

        fetchedResultsController.fetchRequest.predicate = searchPredicate
        
        do {
            try fetchedResultsController.performFetch()
        } catch {
            print(error)
        }
    }

    func synchronizeData(completion: @escaping () -> Void) {
        YandexDiskSynchronizatinManager.shared.syncData {
            completion()
        }
    }
    
    func getNumberOfSections() -> Int {
        guard let sections = fetchedResultsController.sections else {
            return 0
        }
        return sections.count
    }
    
    func getNumberOfRowsInSection(_ section: Int) -> Int {
        guard let sections = fetchedResultsController.sections else {
            return 0
        }
        return sections[section].numberOfObjects
    }
    
    func getNote(at indexPath: IndexPath) -> NoteMO {
        fetchedResultsController.object(at: indexPath)
    }
    
    @objc private func managedObjectContextDidSave(notification: Notification) {
        let viewContext = persistentContainer.viewContext
        
        viewContext.perform {
            viewContext.mergeChanges(fromContextDidSave: notification)
        }
    }
}
