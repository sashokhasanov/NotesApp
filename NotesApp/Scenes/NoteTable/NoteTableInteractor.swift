//
//  NoteTableInteractor.swift
//  NotesApp
//
//  Created by Сашок on 14.05.2022.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import CoreData

protocol NoteTableBusinessLogic {
    func fetchNotes()
    func addNote()
    func deleteNote(request: NoteTable.DeleteNote.Request)
    func pinNote(request: NoteTable.PinNote.Request)
    func filterNotes(request: NoteTable.FiletrNotes.Request)
    func synchronizeData()
}

protocol NoteTableDataStore {
    func getNumberOfSections() -> Int
    func getNumberOfRowsInSection(_ section: Int) -> Int
    func getNote(at indexPath: IndexPath) -> NoteMO
}

class NoteTableInteractor: NSObject {
    var presenter: NoteTablePresentationLogic?
    
    private lazy var worker: NoteTableWorker = {
        let persistentContainer = CoreDataStackHolder.shared.persistentContainer
        let worker =
            NoteTableWorker(persistentContainer: persistentContainer, fetchedResultsControllerDelegate: self)
        return worker
    }()
}

// MARK: - NoteTableBusinessLogic protocol conformance
extension NoteTableInteractor: NoteTableBusinessLogic {
    func fetchNotes() {
        worker.fetchNotes()
    }
    
    func addNote() {
        worker.addNote() { indexPath in
            let response = NoteTable.AddNote.Response(newNoteIndexPath: indexPath)
            self.presenter?.presentNewNote(response: response)
        }
    }
    
    func deleteNote(request: NoteTable.DeleteNote.Request) {
        worker.deleteNote(at: request.indexPath)
    }
    
    func pinNote(request: NoteTable.PinNote.Request) {
        worker.pinNote(at: request.indexPath)
    }
    
    func filterNotes(request: NoteTable.FiletrNotes.Request) {
        worker.filterNotes(searchText: request.searchText)
        presenter?.interactorDidFinishFilteringNotes()
    }
    
    func synchronizeData() {
        worker.synchronizeData {
            self.presenter?.interactorDidFinishDataSynchronization()
        }
    }
}

// MARK: - NoteTableDataStore protocol conformance
extension NoteTableInteractor: NoteTableDataStore {
    func getNumberOfSections() -> Int {
        worker.getNumberOfSections()
    }
    
    func getNumberOfRowsInSection(_ section: Int) -> Int {
        worker.getNumberOfRowsInSection(section)
    }
    
    func getNote(at indexPath: IndexPath) -> NoteMO {
        worker.getNote(at: indexPath)
    }
}

// MARK: - NSFetchedResultsControllerDelegate protocol conformance
extension NoteTableInteractor: NSFetchedResultsControllerDelegate {
    func controllerWillChangeContent(_ controller: NSFetchedResultsController<NSFetchRequestResult>) {
        presenter?.interactorDidBeginDataUpdate()
    }
    
    func controller(_ controller: NSFetchedResultsController<NSFetchRequestResult>,
                    didChange anObject: Any, at indexPath: IndexPath?, for type: NSFetchedResultsChangeType, newIndexPath: IndexPath?) {
        
        var updateKind: NoteTable.UpdateData.UpdateKind?
        
        switch type {
        case .insert:
            updateKind = .insert
        case .update:
            updateKind = .update
        case .move:
            updateKind = .move
        case .delete:
            updateKind = .delete
        @unknown default:
            break
        }
        
        let response = NoteTable.UpdateData.Response(updatekind: updateKind,
                                                     indexPath: indexPath,
                                                     newIndexPath: newIndexPath)
        presenter?.presentDataUpdate(response: response)
    }

    func controllerDidChangeContent(_ controller: NSFetchedResultsController<NSFetchRequestResult>) {
        presenter?.interactorDidEndDataUpdate()
    }
}
